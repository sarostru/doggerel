; stanza has no square root?
; Pasting in some scheme code from when I did sicp 1.3
; (define (fixed-point f first-guess)
;   (define (close-enough? x y)
;     (< (abs (- x y)) tolerance))
;   (define (try i guess)
;     (let ((next (f guess)))
;       (display-guess i next)
;       (if (close-enough? guess next)
;         next
;         (try (+ i 1) next))))
;   (display-guess 0 first-guess)
; (try 1 first-guess))
; 
; (define (deriv g)
;   (lambda (x)
;     (/ (- (g (+ x dx)) (g x)) dx)))
; (define dx 0.00001)
; (define (cube x)
;   (* x x x))
; ;: ((deriv cube) 5)
; 
; (define (newton-transform g)
;   (lambda (x)
;     (- x (/ (g x) ((deriv g) x)))))
; (define (newtons-method g guess)
;   (fixed-point (newton-transform g) guess))
; (define (sqrt x)
;   (newtons-method (lambda (y)
;     (- (square y) x))
; 1.0))
defn is-close?<?T> (a:?T b:T, rel_tol:T, abs_tol:T) -> Bool
    ; Nice version of is-close? Lifted from Chris Barker's PEP 485 proposal, https://www.python.org/dev/peps/pep-0485/
    ; Default rtol = 1e-9 and default atol=0.0, but basically these are application specific numbers
    ; and should always be specified, those numbers will just not be too surprising for naive usage
    abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
    
; TODO:: Use the Maybe type    
defn fixed-point<?T> (f:(?T -> T), guess:T, rel_tol:T, abs_tol:T, max_iter:Int) -> T|False:
    defn try-guess (i:Int, x:T):
        label<T> return:
            val y = f(x)
            if is-close?(x, y, rtol, atol):
                return(y)
            else:
                if i == max_iter:
                    return(false)
                try-guess(i + 1, y)
        

defn newton-raphson<?T> (x:T, f:(T->T), rtol:T, atol:T):
    ; While result not close enough, iterate
    7
