defpackage skanren:
    import core
    import collections
    import typeof

; mukanren commands
; `(var, var?, var=?)
; `(walk, ext-s, u=)
; `(unit, mzero)
; `(unify)
; `(call/fresh)
; `(conj, disj)
; `(mplus, bind)

; support functionality I probably need to implement it in 
; a similar way to the paper
; `(lambda, apply, define)
; `(print)

; TODO:: How to define aliases for types?
; deftype PrimitiveType = Int|String
; deftype Expression = List|PrimitiveType

; defn make-env ():
;     HashTable<StringSymbol, List|Int|String>()


; How to do type aliases?
; defstruct Environment <: HashTable<StringSymbol, List|Int|String>
deftype Universe <: Table<StringSymbol, True|False|List|Array|Int|String>
defmulti add-layer (env:Universe) -> False
defmulti remove-layer (env:Universe) -> False
defmulti set-direct (env:Universe, k:StringSymbol, v) -> False


public defn Universe ():
    val universe = Vector<HashTable<StringSymbol, True|False|List|Array|Int|String>>()
    add(universe, HashTable<StringSymbol, True|False|List|Array|Int|String>())
    new Universe :
        ; Table Implementation Methods
        defmethod to-seq (this):
            cat-all(universe)
        defmethod length (this):
            sum(seq(length, universe))
        defmethod set (this, k:StringSymbol, v):
            match(find(key?{_, k}, in-reverse(universe))):
                (env:Table) : env[k] = v
                (env:False) : peek(universe)[k] = v
        defmethod get? (this, k, d):
            match(find(key?{_, k}, in-reverse(universe))):
                (env:Table) : env[k]
                (env:False) : d 
        defmethod remove (this, k:StringSymbol):
            match(find(key?{_, k}, in-reverse(universe))):
                (env:Table) : remove(env, k)
                (env:False) : false
        defmethod clear (this):
            clear(universe)

        ; Universe specific function calls
        defmethod add-layer (this):
            add(universe, HashTable<StringSymbol, True|False|List|Array|Int|String>())
        defmethod remove-layer (this):
            pop(universe)
            false
        defmethod set-direct (this, k, v):
            peek(universe)[k] = v


defn apply (env, lambda, args) -> True|False|List|Array|Int|String:
    println("apply: lambda = %_, args = %_" % [lambda, args])
    val arg_names = lambda[1]
    val body = lambda[2]
    ; no laziness here, eval those args!
    val evaled-args = map({eval(env, _)}, args)
    ; extend environment
    add-layer(env)
    ; map({env[gensym(_)] = _}, arg_names, evaled-args)
    map({set-direct(env, _, _)}, arg_names, evaled-args)
    println("apply: env = %," % [env])
    println("apply: body = %_" % [body])
    ; eval in that environment
    val result = eval(env, body)
    println("apply: result = %_" % [result])
    ; clean up
    remove-layer(env)
    result


defn eval-cond (env:Universe, L) -> True|False|List|Array|Int|String:
    ; Not handling else correctly here, also not sure about what correct behaviour is
    ; if nothing matches, do nothing or raise error?
    defn eval-item (v):
        if head(v) == `else :
            One(last(v))
        else:
            match(eval(env, head(v))):
                (r:True) : One(last(v))
                (r:False) : None()
    match(first(eval-item, L)):
        (v:One) : eval(env, value(v)) 
        (v:None) : false


defn eval-exp (env:Universe, s-exp) -> True|False|List|Array|Int|String:
    val L = s-exp
    ; curly braces are partial function evaluation
    switch {head(L) == _}:
        `+ : 
            val a = eval(env, L[1]) as Int
            val b = eval(env, L[2]) as Int
            val c:Int = a + b
            println("%_ + %_ = %_" % [a, b, c])
            c
        `define :
            println("define(%_, %_)" % [L[1], L[2]])
            ; I think we need to wrap everything in Maybes, since by adding booleans I have
            ; mixed up the meaning of false, in the first pass false wasn't in the language so 
            ; it meant an underlying language thing only, but now define returns false so it
            ; can work as part of a predicate which is weird
            env[L[1]] = eval(env, L[2])
        `lambda :
            println("lambda: %@" % [L])
            println("lambda-types: %@" % [seq(object-type, L)])
            L
        `procedure? :
            println("procedure? %_" % [L[1]])
            match(eval(env, L[1])):
                (v:List) :
                    false when empty?(v) else head(v) == `lambda
                (v:True|False|Int|String) : false
        `let :
            println("let %@" % [tail(L)])
            val lambda = List(`lambda, map(head, L[1]), L[2])
            val args = map(last, L[1])
            apply(env, lambda, args)
        `cond :
            println("cond %@" % [tail(L)])
            eval-cond(env, tail(L))
        `= :
            println("= %@" % [tail(L)])
            eval(env, L[1]) == eval(env, L[2])
        `if :
            println("if %@" % [tail(L)])
            val cond-exp = List(List(L[1], L[2]), List(`else, L[3]))
            eval-cond(env, cond-exp)
        `and :
            println("and %@" % [tail(L)])
            var acc = true
            label<False> break:
                for v in tail(L) do:
                    acc = acc and (eval(env, v) as True|False)
                    if not acc: break(false)
            acc
        `cons :
            println("cons %@" % [tail(L)])
            cons(eval(env, L[1]), eval(env, L[2]) as List)
        `car :
            println("car %@" % [tail(L)])
            head(eval(env, L[1]) as List)
        `cdr :
            println("cdr %@" % [tail(L)])
            tail(eval(env, L[1]) as List)
        `null? :
            println("null? %@" % [tail(L)])
            eval(env, L[1]) == `()
        `vector :
            println("vector %@" % [tail(L)])
            to-array<True|False|List|Array|Int|String>(map({eval(env, _)}, tail(L)))
        `vector-ref :
            println("vector-ref %@" % [tail(L)])
            get(eval(env, L[1]) as Array, eval(env, L[2]) as Int)
        `@quote :
            println("quote %@" % [tail(L)])
            ; Not sure how to implement this? Can probably do without
            tail(L)
        else :
            val lambda = eval(env, head(L))
            eval(env, cons(lambda, tail(L))) 


public defn eval (env:Universe, s-exp) -> True|False|List|Array|Int|String:
    println("s-exp = %_, type = %_" % [s-exp, object-type(s-exp)])
    match(s-exp):
        (b:True|False) :
            println("Bool(%_)" % [b])
            b
        (i:Int) :
            println("Int(%_)" % [i])
            i
        (s:String) :
            println("String(%_)" % [s])
            s
        (x:StringSymbol) :
            println("%_ = %_" % [x, get?(env, x)])
            env[x]
        (L:List) :
            if empty?(L):
                L
            else:
                match(head(L)):
                    (l:StringSymbol) : eval-exp(env, L)
                    (l:List) : apply(env, head(L), tail(L))
